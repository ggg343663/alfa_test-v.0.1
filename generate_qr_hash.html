<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generate QR Hash (Double Hash Function)</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <style>
        body {
            background-color: #f8f9fa;
            font-family: Arial, sans-serif;
            color: #333;
        }
        .container {
            max-width: 600px;
            margin-top: 30px;
            margin-bottom: 30px;
            background-color: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        h2 {
            color: #28a745;
            text-align: center;
            margin-bottom: 25px;
            font-weight: bold;
        }
        .info-bar {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.1em;
        }
        .info-bar .role-display,
        .info-bar .quota-display,
        .info-bar .status-display {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 5px;
            margin: 0 5px;
            font-weight: bold;
        }
        .info-bar .role-display {
            background-color: #e9ecef;
            color: #495057;
        }
        .info-bar .quota-display {
            background-color: #e9ecef;
            color: #495057;
        }
        .info-bar .status-display.available {
            background-color: #d4edda;
            color: #28a745;
        }
        .info-bar .status-display.not-available {
            background-color: #f8d7da;
            color: #dc3545;
        }
        .info-bar .status-display.ready {
            background-color: #d1ecf1;
            color: #17a2b8;
        }
        .section-block {
            background-color: #f2f2f2;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #e0e0e0;
        }
        .section-block h5 {
            color: #007bff;
            margin-bottom: 15px;
            font-weight: bold;
        }
        .form-group label {
            font-weight: bold;
            color: #555;
        }
        .form-control {
            border-radius: 5px;
            border-color: #ced4da;
        }
        .form-control.is-invalid {
            border-color: #dc3545;
            padding-right: calc(1.5em + .75rem);
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='%23dc3545' viewBox='-2 -2 7 7'%3e%3cpath stroke='%23dc3545' d='M0 0l3 3m0-3L0 3'/%3e%3ccircle r='.5'/%3e%3ccircle cx='3' r='.5'/%3e%3ccircle cy='3' r='.5'/%3e%3ccircle cx='3' cy='3' r='.5'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: center right calc(.375em + .1875rem);
            background-size: calc(.75em + .375rem) calc(.75em + .375rem);
        }
        .invalid-feedback {
            display: block;
            margin-top: .25rem;
            font-size: 80%;
            color: #dc3545;
        }
        .btn-primary {
            background-color: #007bff;
            border-color: #007bff;
            width: 100%;
            padding: 12px;
            font-size: 1.1em;
            font-weight: bold;
            border-radius: 5px;
            margin-top: 20px;
        }
        .btn-primary:hover {
            background-color: #0056b3;
            border-color: #0056b3;
        }
        .btn-light {
            border: 1px solid #ced4da;
            color: #333;
        }
        .btn-light.active {
            background-color: #007bff;
            color: #fff;
            border-color: #007bff;
        }
        .qr-display-area {
            text-align: center;
            padding: 20px;
            background-color: #f2f2f2;
            border-radius: 8px;
            margin-top: 20px;
            border: 1px solid #e0e0e0;
        }
        .qr-display-area img {
            max-width: 150px;
            height: auto;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            padding: 5px;
        }
        .qr-display-area h5 {
            color: #007bff;
            margin-bottom: 10px;
        }
        .hash-output {
            background-color: #e9ecef;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            word-break: break-all;
            margin-bottom: 10px;
            color: #333;
            text-align: left;
            position: relative; /* For copy button positioning */
        }
        .hash-output .copy-btn {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #007bff;
            font-size: 0.9em;
            cursor: pointer;
        }
        .hash-output .copy-btn:hover {
            text-decoration: underline;
        }
        .audit-chain-section {
            margin-top: 30px;
        }
        .navigation-buttons {
            display: flex;
            justify-content: space-around;
            margin-top: 30px;
        }
        .navigation-buttons .btn {
            flex: 1;
            margin: 0 5px;
            padding: 10px 0;
            font-size: 1em;
            font-weight: bold;
        }
        .secret-input-group .input-group-append {
            cursor: pointer;
        }
        .password-strength-bar {
            height: 8px;
            border-radius: 4px;
            margin-top: 5px;
            background-color: #e9ecef; /* Default empty state */
        }
        .strength-weak { background-color: #dc3545; width: 25%; }
        .strength-moderate { background-color: #ffc107; width: 50%; }
        .strength-strong { background-color: #28a745; width: 75%; }
        .strength-very-strong { background-color: #007bff; width: 100%; }

        .qr-gallery-upload, .qr-scan-btn {
            background-color: #6c757d;
            border-color: #6c757d;
            color: #fff;
            margin-top: 10px;
            width: 100%;
        }
        .qr-gallery-upload:hover, .qr-scan-btn:hover {
            background-color: #5a6268;
            border-color: #5a6268;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Generate QR Hash (Double Hash Function)</h2>

        <div class="info-bar mb-4">
            <span class="role-display">Role: <span id="userRole"></span></span>
            <span class="quota-display">Quota: <span id="usedQuota"></span> / <span id="totalQuota"></span></span>
            <span class="status-display" id="quotaStatus"></span>
        </div>

        <div class="section-block">
            <h5>Public Key</h5>
            <div class="form-group">
                <label for="public_key">Public Key</label>
                <div class="input-group">
                    <input type="text" id="public_key" class="form-control" placeholder="Paste your public key here">
                    <div class="input-group-append">
                        <button class="btn btn-outline-secondary" type="button" id="pastePublicKeyBtn"><i class="fas fa-paste"></i> Paste</button>
                    </div>
                </div>
                <small class="form-text text-muted">Use the public key from the "Generate Key" page (64 hex characters).</small>
                <div class="invalid-feedback" id="public_key_feedback"></div>
                <small class="form-text text-muted" id="public_key_length_feedback">Length: 0</small>
            </div>
            <button class="btn btn-info btn-block qr-scan-btn" id="scanQrBtn"><i class="fas fa-qrcode"></i> Scan QR Code</button>
            <input type="file" accept="image/*" style="display:none;" id="uploadQrImageInput">
            <button class="btn btn-info btn-block qr-gallery-upload" id="uploadQrImageBtn"><i class="fas fa-image"></i> Upload QR Image</button>
        </div>

        <div class="section-block" id="qr_group_name_section" style="display:none;">
            <h5>QR Group Name</h5>
            <div class="form-group">
                <input type="text" id="group_name" class="form-control" placeholder="Enter a group name (e.g., event name, product batch)">
                <small class="form-text text-muted" id="group_name_hint"></small>
                <div class="invalid-feedback" id="group_name_feedback"></div>
            </div>
        </div>

        <div class="section-block">
            <h5>Quantity (QTY)</h5>
            <div class="form-group quantity-input-container">
                <label for="quantity">Number of QR to Generate</label>
                <div class="btn-group d-flex" role="group" aria-label="Quantity options">
                    <button type="button" class="btn btn-light flex-fill" data-quantity="1">1</button>
                    <button type="button" class="btn btn-light flex-fill" data-quantity="100">100</button>
                    <button type="button" class="btn btn-light flex-fill" data-quantity="500">500</button>
                    <button type="button" class="btn btn-light flex-fill" data-quantity="1000">1000</button>
                    <button type="button" class="btn btn-light flex-fill" data-quantity="3000">3000</button>
                    <button type="button" class="btn btn-light flex-fill" data-quantity="5000">5000</button>
                </div>
                <input type="number" id="quantity" class="form-control mt-3" placeholder="Enter a custom amount" min="1">
                <small class="form-text text-muted" id="quantity_hint"></small>
                <div class="invalid-feedback" id="quantity_feedback"></div>
            </div>
        </div>

        <div class="section-block">
            <h5>Secret (4 a-z for minting only)</h5>
            <div class="form-group">
                <label for="secret">Secret</label>
                <div class="input-group secret-input-group">
                    <input type="password" id="secret" class="form-control" placeholder="For secure minting (keep private)">
                    <div class="input-group-append" onclick="toggleSecretVisibility()">
                        <span class="input-group-text"><i id="secret_eye_icon" class="fas fa-eye"></i></span>
                    </div>
                </div>
                <div class="password-strength-bar" id="secret_strength_bar"></div>
                <small class="form-text text-muted">4 characters a-z (lowercase)</small>
                <div class="invalid-feedback" id="secret_feedback"></div>
            </div>
            <div class="form-group">
                <label for="confirm_secret">Confirm Secret</label>
                <div class="input-group secret-input-group">
                    <input type="password" id="confirm_secret" class="form-control" placeholder="Type secret again">
                    <div class="input-group-append" onclick="toggleConfirmSecretVisibility()">
                        <span class="input-group-text"><i id="confirm_secret_eye_icon" class="fas fa-eye"></i></span>
                    </div>
                </div>
                <div class="invalid-feedback" id="confirm_secret_feedback"></div>
            </div>
        </div>

        <div class="section-block" id="captcha-block">
            <h5>Security Check</h5>
            <div class="form-group text-center">
                <p>Please solve this simple math problem:</p>
                <p class="h4"><span id="num1"></span> + <span id="num2"></span> = ?</p>
                <input type="number" id="captcha-answer" class="form-control d-inline-block w-50" placeholder="Your answer">
                <div class="invalid-feedback" id="captcha_feedback"></div>
            </div>
        </div>

        <button class="btn btn-primary" id="generateQRBatchBtn">Generate QR Hashes</button>

        <div id="qr_display_results" class="qr-display-area" style="display:none;">
            <h5>QR Batch Generated</h5>
            <img src="qr_placeholder.png" alt="QR Code" id="qr_code_image">
            <p><strong>QR Hash (hash1):</strong></p>
            <div class="hash-output" id="qr_hash_output">
                <span id="hash1_value"></span>
                <button class="copy-btn" onclick="copyToClipboard('hash1_value')">Copy</button>
            </div>
            <p><strong>Commitment Hash (hash2):</strong></p>
            <div class="hash-output" id="commitment_hash_output">
                <span id="hash2_value"></span>
                <button class="copy-btn" onclick="copyToClipboard('hash2_value')">Copy</button>
            </div>

            <div class="mt-4 text-left">
                <h6>ส่วนประกอบสำคัญสำหรับ Hash:</h6>
                <div class="hash-output">
                    Timestamp: <span id="timestamp_value"></span>
                    <button class="copy-btn" onclick="copyToClipboard('timestamp_value')">Copy</button>
                </div>
                <div class="hash-output">
                    Nonce: <span id="nonce_value"></span>
                    <button class="copy-btn" onclick="copyToClipboard('nonce_value')">Copy</button>
                </div>
                <div class="hash-output">
                    Slot ID (example): <span id="slot_id_value"></span>
                    <button class="copy-btn" onclick="copyToClipboard('slot_id_value')">Copy</button>
                </div>
                <div class="hash-output">
                    Prev Hash (first 6 chars): <span id="prev_hash_value"></span>
                    <button class="copy-btn" onclick="copyToClipboard('prev_hash_value')">Copy</button>
                </div>
            </div>

            <button class="btn btn-warning mt-4 w-100" id="exportTicketBtn">Export Ticket (TXT/JSON)</button>
            <button class="btn btn-info mt-2 w-100" id="exportQrBtn">Export QR (PNG/ZIP)</button>
            <button class="btn btn-secondary mt-2 w-100" id="exportCommitmentLogBtn">Export Commitment Log (CSV/JSON)</button>

            <button class="btn btn-success mt-4 w-100" id="commitBtn">Commit (Simulated)</button>
        </div>

        <div class="section-block audit-chain-section">
            <h5>Audit Chain</h5>
            <div class="form-group">
                <label for="audit_hash_input">QR/Commitment Hash (hash2)</label>
                <input type="text" id="audit_hash_input" class="form-control" placeholder="Paste QR or Commitment hash (hash2)">
            </div>
            <button class="btn btn-primary w-100">Audit Chain</button>
        </div>

        <div class="navigation-buttons">
            <button class="btn btn-outline-secondary" onclick="window.location.href='index.html'">Back</button>
            <button class="btn btn-outline-secondary" onclick="window.location.href='index.html'">Home</button>
            <button class="btn btn-outline-secondary" onclick="window.location.href='next_page.html'">Next</button>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://cdn.rawgit.com/davidshimjs/qrcodejs/gh-pages/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode"></script>

    <script>
        // --- Dummy Data & Initial Setup ---
        let currentUserRole = 'Normal'; // Can be 'Normal', 'Agent', 'Master'
        let hasMintedFirstQr = false; // For Normal user's first 1 QR limit
        let dummyMasterHash = "0x0000000000000000000000000000000000000000000000000000000000000000"; // This should come from a real system
        let dummyAgentHash = "0x0000000000000000000000000000000000000000000000000000000000000000"; // This should come from a real system
        const PUBLIC_KEY_LENGTH = 64; // Example for hex (32 bytes)

        const roles = {
            'Normal': {
                initialQuota: 1, // First time user
                subsequentQuota: 1000,
                canSpecifyGroup: false,
                prevHash: dummyMasterHash // Assume Normal users mint under Master
            },
            'Agent': {
                quota: 3000,
                canSpecifyGroup: true,
                prevHash: dummyAgentHash // Assume Agents mint under Agent
            },
            'Master': {
                quota: 100000, // Very high or unlimited
                canSpecifyGroup: true,
                prevHash: dummyMasterHash // Master mints under Master
            }
        };

        // --- DOM Elements ---
        const userRoleSpan = document.getElementById('userRole');
        const usedQuotaSpan = document.getElementById('usedQuota');
        const totalQuotaSpan = document.getElementById('totalQuota');
        const quotaStatusSpan = document.getElementById('quotaStatus');

        const publicKeyInput = document.getElementById('public_key');
        const publicKeyFeedback = document.getElementById('public_key_feedback');
        const publicKeyLengthFeedback = document.getElementById('public_key_length_feedback');
        const pastePublicKeyBtn = document.getElementById('pastePublicKeyBtn');
        const scanQrBtn = document.getElementById('scanQrBtn');
        const uploadQrImageInput = document.getElementById('uploadQrImageInput');
        const uploadQrImageBtn = document.getElementById('uploadQrImageBtn');

        const qrGroupNameSection = document.getElementById('qr_group_name_section');
        const groupNameInput = document.getElementById('group_name');
        const groupNameHint = document.getElementById('group_name_hint');
        const groupNameFeedback = document.getElementById('group_name_feedback');

        const quantityInput = document.getElementById('quantity');
        const quantityButtons = document.querySelectorAll('.btn-group .btn');
        const quantityHint = document.getElementById('quantity_hint');
        const quantityFeedback = document.getElementById('quantity_feedback');

        const secretInput = document.getElementById('secret');
        const confirmSecretInput = document.getElementById('confirm_secret');
        const secretFeedback = document.getElementById('secret_feedback');
        const confirmSecretFeedback = document.getElementById('confirm_secret_feedback');
        const secretStrengthBar = document.getElementById('secret_strength_bar');
        const secretEyeIcon = document.getElementById('secret_eye_icon');
        const confirmSecretEyeIcon = document.getElementById('confirm_secret_eye_icon');

        const captchaNum1Span = document.getElementById('num1');
        const captchaNum2Span = document.getElementById('num2');
        const captchaAnswerInput = document.getElementById('captcha-answer');
        const captchaFeedback = document.getElementById('captcha_feedback');

        const generateQRBatchBtn = document.getElementById('generateQRBatchBtn');
        const qrDisplayResults = document.getElementById('qr_display_results');
        const qrCodeImage = document.getElementById('qr_code_image');

        // --- Global Variables ---
        let currentUsedQuota = 0;
        let totalQuota = 0;
        let prevHashForMinting = dummyMasterHash; // Default

        // --- Captcha Variables ---
        let captchaNum1, captchaNum2;

        // --- Helper Functions ---
        function generateNonce(length) {
            let result = '';
            const characters = 'abcdefghijklmnopqrstuvwxyz0123456789';
            const charactersLength = characters.length;
            for (let i = 0; i < length; i++) {
                result += characters.charAt(Math.floor(Math.random() * charactersLength));
            }
            return result;
        }

        function calculateHash(data) {
            // Simple hash simulation for demonstration
            // In a real application, use a strong cryptographic hash function (e.g., SHA-256)
            let hash = 0;
            for (let i = 0; i < data.length; i++) {
                const char = data.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash |= 0; // Convert to 32bit integer
            }
            return Math.abs(hash).toString(16).padStart(64, '0').substring(0, 64); // Ensure 64 char hex string
        }

        function copyToClipboard(elementId) {
            const element = document.getElementById(elementId);
            const textToCopy = element.textContent || element.value;
            navigator.clipboard.writeText(textToCopy)
                .then(() => {
                    // Optional: Show a temporary success message
                    console.log('Copied to clipboard:', textToCopy);
                })
                .catch(err => {
                    console.error('Failed to copy: ', err);
                });
        }

        function setInvalid(element, feedbackElement, message) {
            element.classList.add('is-invalid');
            feedbackElement.textContent = message;
        }

        function setValid(element, feedbackElement) {
            element.classList.remove('is-invalid');
            feedbackElement.textContent = '';
        }

        // --- Quota & Role Management ---
        function updateQuotaDisplay() {
            usedQuotaSpan.textContent = currentUsedQuota;
            totalQuotaSpan.textContent = totalQuota;

            if (currentUsedQuota < totalQuota) {
                quotaStatusSpan.textContent = 'Available';
                quotaStatusSpan.classList.remove('not-available', 'ready');
                quotaStatusSpan.classList.add('available');
            } else if (currentUsedQuota === totalQuota && totalQuota > 0) {
                quotaStatusSpan.textContent = 'Ready (Maxed out)'; // Or "All used"
                quotaStatusSpan.classList.remove('available', 'not-available');
                quotaStatusSpan.classList.add('ready');
            } else {
                quotaStatusSpan.textContent = 'Not Available';
                quotaStatusSpan.classList.remove('available', 'ready');
                quotaStatusSpan.classList.add('not-available');
            }
            updateQuantityOptions();
        }

        function initializeUserRole(role) {
            currentUserRole = role;
            userRoleSpan.textContent = currentUserRole;

            if (currentUserRole === 'Normal') {
                totalQuota = hasMintedFirstQr ? roles.Normal.subsequentQuota : roles.Normal.initialQuota;
                groupNameHint.textContent = "Group name is not required for Normal users.";
                qrGroupNameSection.style.display = 'none';
                prevHashForMinting = roles.Normal.prevHash;
            } else if (currentUserRole === 'Agent') {
                totalQuota = roles.Agent.quota;
                groupNameHint.textContent = "Enter a group name for your QR batch (required for Agent).";
                qrGroupNameSection.style.display = 'block';
                prevHashForMinting = roles.Agent.prevHash;
            } else if (currentUserRole === 'Master') {
                totalQuota = roles.Master.quota;
                groupNameHint.textContent = "Enter a group name for your QR batch (optional for Master).";
                qrGroupNameSection.style.display = 'block';
                prevHashForMinting = roles.Master.prevHash;
            }
            updateQuotaDisplay();
        }

        function updateQuantityOptions() {
            const maxAllowed = totalQuota - currentUsedQuota;
            quantityInput.max = maxAllowed;
            quantityHint.textContent = `You can generate up to ${maxAllowed} QR Hashes.`;

            quantityButtons.forEach(button => {
                const q = parseInt(button.dataset.quantity);
                if (q > maxAllowed) {
                    button.disabled = true;
                    button.classList.add('disabled');
                } else {
                    button.disabled = false;
                    button.classList.remove('disabled');
                }
            });

            if (currentUserRole === 'Normal' && !hasMintedFirstQr) {
                quantityInput.value = 1;
                quantityInput.disabled = true;
                quantityButtons.forEach(button => {
                    button.disabled = true;
                    button.classList.add('disabled');
                    if (parseInt(button.dataset.quantity) === 1) {
                        button.disabled = false;
                        button.classList.remove('disabled');
                        button.classList.add('active'); // Highlight the 1 button
                    }
                });
                quantityHint.textContent = "As a new Normal user, you can mint only 1 QR Hash. After that, your quota will be 1000.";
            } else {
                quantityInput.disabled = false;
            }
        }

        // --- Validation Functions ---
        function validatePublicKey() {
            const key = publicKeyInput.value.trim();
            publicKeyLengthFeedback.textContent = `Length: ${key.length}`;

            if (key === '') {
                setInvalid(publicKeyInput, publicKeyFeedback, 'Public Key is required.');
                return false;
            }
            if (key.length !== PUBLIC_KEY_LENGTH) {
                setInvalid(publicKeyInput, publicKeyFeedback, `Public Key must be ${PUBLIC_KEY_LENGTH} characters.`);
                return false;
            }
            if (!/^[0-9a-fA-F]+$/.test(key)) {
                setInvalid(publicKeyInput, publicKeyFeedback, 'Public Key must be hexadecimal characters (0-9, a-f, A-F).');
                return false;
            }
            setValid(publicKeyInput, publicKeyFeedback);
            return true;
        }

        function validateGroupName() {
            const groupName = groupNameInput.value.trim();
            if (currentUserRole === 'Agent' && groupName === '') {
                setInvalid(groupNameInput, groupNameFeedback, 'Group Name is required for Agent.');
                return false;
            }
            setValid(groupNameInput, groupNameFeedback);
            return true;
        }

        function validateQuantity() {
            const qty = parseInt(quantityInput.value);
            const maxAllowed = totalQuota - currentUsedQuota;

            if (isNaN(qty) || qty <= 0) {
                setInvalid(quantityInput, quantityFeedback, 'Quantity must be a positive number.');
                return false;
            }
            if (qty > maxAllowed) {
                setInvalid(quantityInput, quantityFeedback, `You can only generate up to ${maxAllowed} QR Hashes.`);
                return false;
            }
            if (currentUserRole === 'Normal' && !hasMintedFirstQr && qty !== 1) {
                setInvalid(quantityInput, quantityFeedback, 'As a new Normal user, you can only generate 1 QR Hash.');
                return false;
            }
            setValid(quantityInput, quantityFeedback);
            return true;
        }

        function calculateSecretStrength(secret) {
            let strength = 0;
            if (secret.length >= 4) strength += 1;
            if (/[a-z]/.test(secret)) strength += 1;
            // For the current requirement of "4 characters a-z (lowercase)", this is simplified.
            // If requirements change to more complex passwords, add more logic:
            // if (/[A-Z]/.test(secret)) strength += 1;
            // if (/[0-9]/.test(secret)) strength += 1;
            // if (/[^a-zA-Z0-9]/.test(secret)) strength += 1;

            return strength; // 0-4
        }

        function updateSecretStrengthBar() {
            const secret = secretInput.value;
            const strength = calculateSecretStrength(secret);

            secretStrengthBar.className = 'password-strength-bar'; // Reset classes
            if (secret.length === 0) {
                // No strength if empty
            } else if (strength < 2) {
                secretStrengthBar.classList.add('strength-weak');
            } else if (strength < 3) {
                secretStrengthBar.classList.add('strength-moderate');
            } else if (strength < 4) {
                secretStrengthBar.classList.add('strength-strong');
            } else {
                secretStrengthBar.classList.add('strength-very-strong');
            }
        }

        function validateSecret() {
            const secret = secretInput.value;
            const confirmSecret = confirmSecretInput.value;
            let isValid = true;

            if (secret === '') {
                setInvalid(secretInput, secretFeedback, 'Secret is required.');
                isValid = false;
            } else if (secret.length !== 4) {
                setInvalid(secretInput, secretFeedback, 'Secret must be 4 characters long.');
                isValid = false;
            } else if (!/^[a-z]+$/.test(secret)) {
                setInvalid(secretInput, secretFeedback, 'Secret must contain only lowercase English letters (a-z).');
                isValid = false;
            } else {
                setValid(secretInput, secretFeedback);
            }

            if (confirmSecret === '') {
                setInvalid(confirmSecretInput, confirmSecretFeedback, 'Confirm Secret is required.');
                isValid = false;
            } else if (secret !== confirmSecret) {
                setInvalid(confirmSecretInput, confirmSecretFeedback, 'Secrets do not match.');
                isValid = false;
            } else {
                setValid(confirmSecretInput, confirmSecretFeedback);
            }
            return isValid;
        }

        function generateCaptcha() {
            captchaNum1 = Math.floor(Math.random() * 10) + 1; // 1-10
            captchaNum2 = Math.floor(Math.random() * 10) + 1; // 1-10
            captchaNum1Span.textContent = captchaNum1;
            captchaNum2Span.textContent = captchaNum2;
            captchaAnswerInput.value = ''; // Clear previous answer
            setValid(captchaAnswerInput, captchaFeedback); // Clear any previous error
        }

        function checkCaptcha() {
            const userAnswer = parseInt(captchaAnswerInput.value);
            const correctAnswer = captchaNum1 + captchaNum2;

            if (isNaN(userAnswer) || userAnswer !== correctAnswer) {
                setInvalid(captchaAnswerInput, captchaFeedback, 'Incorrect answer, please try again.');
                generateCaptcha(); // Generate a new problem
                return false;
            }
            setValid(captchaAnswerInput, captchaFeedback);
            return true;
        }

        // --- Event Handlers ---
        pastePublicKeyBtn.addEventListener('click', async () => {
            try {
                const text = await navigator.clipboard.readText();
                publicKeyInput.value = text;
                validatePublicKey();
            } catch (err) {
                alert('Failed to read clipboard. Please paste manually. Make sure your browser allows clipboard access.');
            }
        });

        scanQrBtn.addEventListener('click', () => {
            // Implement QR scanning here (using html5-qrcode library)
            // This is a placeholder. A real implementation would involve a modal or new page.
            alert('QR Scan functionality not fully implemented in this demo. Please use Paste or Upload.');
            // Example basic setup (needs a dedicated video element and proper handling):
            /*
            const html5QrCode = new Html5Qrcode("reader"); // "reader" would be the ID of a video element
            html5QrCode.start(
                { facingMode: "environment" },
                { fps: 10, qrbox: { width: 250, height: 250 } },
                (decodedText, decodedResult) => {
                    publicKeyInput.value = decodedText;
                    validatePublicKey();
                    html5QrCode.stop();
                }
            ).catch(err => {
                console.error("QR Scan failed:", err);
            });
            */
        });

        uploadQrImageBtn.addEventListener('click', () => {
            uploadQrImageInput.click(); // Trigger the hidden file input
        });

        uploadQrImageInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const imageSrc = e.target.result;
                // Use html5-qrcode to decode the image
                Html5Qrcode.decodeFromImage(imageSrc, "decoded-image-name") // "decoded-image-name" is arbitrary
                    .then(decodedText => {
                        publicKeyInput.value = decodedText;
                        validatePublicKey();
                    })
                    .catch(err => {
                        alert('Failed to decode QR from image: ' + err);
                        console.error('Failed to decode QR from image:', err);
                    });
            };
            reader.readAsDataURL(file);
        });

        quantityButtons.forEach(button => {
            button.addEventListener('click', () => {
                quantityButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                quantityInput.value = button.dataset.quantity;
                validateQuantity(); // Re-validate when a button is clicked
            });
        });

        publicKeyInput.addEventListener('input', validatePublicKey);
        groupNameInput.addEventListener('input', validateGroupName);
        quantityInput.addEventListener('input', validateQuantity);
        secretInput.addEventListener('input', () => {
            updateSecretStrengthBar();
            validateSecret(); // Validate both secret fields
        });
        confirmSecretInput.addEventListener('input', validateSecret);
        captchaAnswerInput.addEventListener('input', () => {
            // Clear feedback immediately on input, re-validate on generate attempt
            setValid(captchaAnswerInput, captchaFeedback);
        });


        generateQRBatchBtn.addEventListener('click', generateQRBatch);

        // --- Toggle Secret Visibility ---
        function toggleSecretVisibility() {
            if (secretInput.type === 'password') {
                secretInput.type = 'text';
                secretEyeIcon.classList.remove('fa-eye');
                secretEyeIcon.classList.add('fa-eye-slash');
            } else {
                secretInput.type = 'password';
                secretEyeIcon.classList.remove('fa-eye-slash');
                secretEyeIcon.classList.add('fa-eye');
            }
        }

        function toggleConfirmSecretVisibility() {
            if (confirmSecretInput.type === 'password') {
                confirmSecretInput.type = 'text';
                confirmSecretEyeIcon.classList.remove('fa-eye');
                confirmSecretEyeIcon.classList.add('fa-eye-slash');
            } else {
                confirmSecretInput.type = 'password';
                confirmSecretEyeIcon.classList.remove('fa-eye-slash');
                confirmSecretEyeIcon.classList.add('fa-eye');
            }
        }

        // --- Main Generation Logic ---
        function generateQRBatch() {
            // 1. Validate all inputs
            const isPublicKeyValid = validatePublicKey();
            const isGroupNameValid = validateGroupName();
            const isQuantityValid = validateQuantity();
            const isSecretValid = validateSecret();
            const isCaptchaValid = checkCaptcha();

            if (!isPublicKeyValid || !isGroupNameValid || !isQuantityValid || !isSecretValid || !isCaptchaValid) {
                // Scroll to the first invalid field (optional, for better UX)
                const firstInvalid = document.querySelector('.is-invalid');
                if (firstInvalid) {
                    firstInvalid.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
                return; // Stop if any validation fails
            }

            // 2. All validations passed, proceed with generation
            const publicKey = publicKeyInput.value;
            const groupName = groupNameInput.value || 'N/A'; // N/A if not required/provided
            const quantity = parseInt(quantityInput.value);
            const secret = secretInput.value;
            const currentTimestamp = new Date().toISOString();
            const nonce = generateNonce(8); // 8-character nonce

            const prevHash = prevHashForMinting; // Master Hash or Agent Hash

            // Simulate QR Hash (hash1) calculation
            // In a real system, this would be a secure cryptographic hash function.
            // Data for hash1: prevHash + publicKey + quantity + secret + timestamp + nonce
            const dataForHash1 = prevHash + publicKey + quantity + secret + currentTimestamp + nonce;
            const qrHash = calculateHash(dataForHash1);

            // Simulate Commitment Hash (hash2) calculation
            // Data for hash2: userRole + publicKey + groupName + quantity + qrHash + timestamp + nonce
            const dataForHash2 = currentUserRole + publicKey + groupName + quantity + qrHash + currentTimestamp + nonce;
            const commitmentHash = calculateHash(dataForHash2);

            // Update QR Code Image
            const qrCodeData = qrHash; // You might want to include more data in the QR code itself
            const qrcode = new QRCode(qrCodeImage, {
                text: qrCodeData,
                width: 150,
                height: 150,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.H
            });
            // Note: QRCode.js appends a canvas/img to the element, so clear it first if re-generating
            qrCodeImage.innerHTML = ''; // Clear previous QR if any
            new QRCode(qrCodeImage, {
                text: qrCodeData,
                width: 150,
                height: 150,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.H
            });


            // Display results
            document.getElementById('hash1_value').textContent = qrHash;
            document.getElementById('hash2_value').textContent = commitmentHash;
            document.getElementById('timestamp_value').textContent = currentTimestamp;
            document.getElementById('nonce_value').textContent = nonce;
            document.getElementById('slot_id_value').textContent = `QR_${quantity}_${new Date().getTime()}_01`; // Example Slot ID
            document.getElementById('prev_hash_value').textContent = prevHash.substring(0, 6);

            qrDisplayResults.style.display = 'block';
            generateQRBatchBtn.disabled = true; // Disable generate button after successful generation (until reset or new input)

            // Update quota
            currentUsedQuota += quantity;
            updateQuotaDisplay();

            // For Normal user, if first QR is minted, update quota for next time
            if (currentUserRole === 'Normal' && !hasMintedFirstQr && quantity === 1) {
                hasMintedFirstQr = true;
                initializeUserRole('Normal'); // Re-initialize to update quota to 1000
            }

            // Generate new captcha for next attempt
            generateCaptcha();
        }

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeUserRole('Normal'); // Set initial role. In a real app, this would come from user login.
            generateCaptcha(); // Generate initial captcha
            updateSecretStrengthBar(); // Initial strength check
        });
    </script>
</body>
</html>
